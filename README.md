# Algorithms_hm2


# Анализ алгоритмов сортировки и поиска

## Анализ алгоритма: Сортировка выбором (Selection Sort)

**Определение:**  
Сортировка выбором — алгоритм, который делит массив на отсортированную и неотсортированную части. На каждом шаге выбирается минимальный элемент из неотсортированной части и меняется местами с первым элементом этой части.

**Анализ:**  
Этот алгоритм находит минимальный элемент в неотсортированной части массива и меняет его местами с первым элементом.  
Внешний цикл `for` выполняется \(n-1\) раз.  
Внутренний цикл `for` в худшем случае выполняется последовательно \(n-1, n-2, \ldots\) раз.  
Общее количество сравнений примерно равно \(n \times (n-1)/2\).

**Временная сложность:** \(O(n^2)\)  
**Почему \(O(n^2)\):** Два вложенных цикла, каждый из которых зависит от \(n\). Внутренний цикл может выполняться до \(n\) раз для каждого из \(n\) проходов внешнего цикла.

---

## Анализ алгоритма: Сортировка обменом (пузырьком) (Bubble Sort)

**Определение:**  
Пузырьковая сортировка — простой алгоритм, который многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они расположены в неправильном порядке.

**Анализ:**  
Алгоритм "всплывает" самый большой элемент к концу массива.  
Внешний цикл `for` выполняется \(n-1\) раз.  
Внутренний цикл в худшем случае выполняется последовательно \(n-1, n-2, \ldots\) раз.  
Оптимизация с помощью флага `swapped` позволяет завершить сортировку раньше, если массив уже отсортирован.

**Временная сложность:**  
- Худший случай: \(O(n^2)\) — массив отсортирован в обратном порядке.  
- Лучший случай: \(O(n)\) — массив уже отсортирован.  
- Средний случай: \(O(n^2)\).

**Почему \(O(n^2)\):** Аналогична сортировке выбором, требует порядка \(n \times (n-1)/2\) сравнений и обменов.

---

## Анализ алгоритма: Сортировка вставками (Insertion Sort)

**Определение:**  
Алгоритм, где каждый элемент вставляется в правильное место среди ранее отсортированных.

**Анализ:**  
Отсортированная часть растет как новый элемент вставляется.  
Внешний цикл по \(n-1\) элементу, внутренний может выполнить до \(i\) итераций.

**Временная сложность:**  
- Худший случай: \(O(n^2)\).  
- Лучший случай: \(O(n)\).  
- Средний случай: \(O(n^2)\).

**Почему \(O(n^2)\):** Количество операций равно сумме \(1 + 2 + \ldots + (n-1) = n \times (n-1)/2\).

---

## Анализ алгоритма: Сортировка слиянием (Merge Sort)

**Определение:**  
Рекурсивное деление массива на части и их слияние для создания отсортированного массива.

**Анализ:**  
Делит массив на подмассивы размером 1, а затем сливает их отсортированными функцией merge.

**Временная сложность:** \(O(n \log n)\)  
**Почему:** Глубина рекурсии \(\log n\), на уровне каждый элемент обрабатывается \(n\) раз.

---

## Анализ алгоритма: Сортировка Шелла (Shell Sort)

**Определение:**  
Усовершенствованный вариант вставок, сравнивающий элементы на расстоянии gap, которое постепенно уменьшается.

**Анализ:**  
Сортирует элементы на расстоянии gap, затем уменьшает gap.

**Временная сложность:**  
Зависит от последовательности gap, обычно \(O(n^{3/2})\) или \(O(n \log^2 n)\). Может ухудшаться до \(O(n^2)\).

**Почему:** Внутренний цикл зависит от gap, итерации растут медленнее, чем в простых сортах.

---

## Анализ алгоритма: Быстрая сортировка (Quick Sort)

**Определение:**  
Использует стратегию "разделяй и властвуй", выбирая опорный элемент, разделяя массив на части и рекурсивно сортируя их.

**Анализ:**  
Опорный элемент делит массив на подмассивы элементов меньше и больше его, затем рекурсия.

**Временная сложность:**  
- Средний случай: \(O(n \log n)\).  
- Худший случай: \(O(n^2)\).  
- Лучший случай: \(O(n \log n)\).

**Почему:**  
Глубина рекурсии и количество сравнений зависят от выбора опорного элемента.

---

## Анализ алгоритма: Пирамидальная сортировка (Heap Sort)

**Определение:**  
Использует структуру данных "двойная куча" для эффективной сортировки.

**Анализ:**  
Строит max-heap, затем извлекает максимальные элементы по одному, поддерживая структуру кучи.

**Временная сложность:** \(O(n \log n)\)  
**Почему:**  
Построение кучи — \(O(n)\), сортировка — \(n-1\) вызовов heapify по \(O(\log n)\).

---

## Анализ алгоритма: Последовательный (линейный) поиск (Linear Search)

**Определение:**  
Ищет элемент перебором всех элементов массива один за другим.

**Анализ:**  
Простой перебор с проверкой каждого элемента.

**Временная сложность:**  
- Худший случай: \(O(n)\).  
- Лучший случай: \(O(1)\).  
- Средний случай: \(O(n)\).

---

## Анализ алгоритма: Бинарный поиск (Binary Search)

**Определение:**  
Эффективный поиск в отсортированном массиве путем деления области поиска пополам.

**Анализ:**  
Сокращает область поиска вдвое на каждом шаге.

**Временная сложность:** \(O(\log n)\).

---

## Анализ алгоритма: Интерполирующий поиск (Interpolation Search)

**Определение:**  
Улучшение бинарного поиска для равномерно распределённых данных, ориентируется на значение элемента.

**Анализ:**  
Рассчитывает позицию элемента, предполагая равномерное распределение.

**Временная сложность:**  
- Средний случай: \(O(\log \log n)\).  
- Худший случай: \(O(n)\).

---

## Анализ алгоритма: Поиск по Фибоначчи (Fibonacci Search)

**Определение:**  
Итеративный поиск с разбиением массива с помощью чисел Фибоначчи.

**Анализ:**  
Использует последовательность Фибоначчи для деления области поиска.

**Временная сложность:** \(O(\log n)\).

---


