# Algorithms_hm2
##Юркова УИБО 14-24


# Сортировка выбором (Selection Sort)

Определение 
Алгоритм, который на каждом шаге находит минимальный элемент в неотсортированной части массива и перемещает его в отсортированную часть.

Анализ: 
На каждой итерации выбирается минимальный элемент и меняется местами с первым элементом оставшейся части массива.  
Внешний цикл проходит $$n-1$$ раз, внутренний — уменьшается от $$n-1$$ до 1.  
Число сравнений приближенно равно $$ \frac{n(n-1)}{2} $$.

Временная сложность: $$O(n^2)$$  
Причина: из-за двойного вложенного цикла, где внешний перебирает элементы, а внутренний — ищет минимум среди оставшихся, количество операций растёт квадратично.


# Сортировка обменом (Bubble Sort)

Определение:  
Простой алгоритм, который многократно проходит по массиву, сравнивая соседние элементы и меняя их местами при необходимости.

Анализ: 
"Всплывающий" самый большой элемент постепенно перемещается в конец массива.  
Выполняется $$n-1$$ проход, внутренние циклы сокращаются с каждым проходом.  
Оптимизация с флагом `swapped` позволяет остановить сортировку досрочно, если массив уже отсортирован.

Временная сложность: $$O(n^2)$$  
Причина: два вложенных цикла, при которых число сравнений приблизительно равно сумме последовательных чисел от 1 до $$n-1$$, давая квадратичную зависимость.

# Сортировка вставками (Insertion Sort)

Определение:  
Алгоритм, который поочерёдно вставляет элементы в отсортированную часть массива, поддерживая порядок.

Анализ:  
Отсортированная часть массива расширяется с каждой вставкой.  
Внутренний цикл перемещает элемент на правильную позицию, выполняя до $$i$$ операций на $$i$$-й итерации.

Временная сложность:  
 $$O(n^2)$$ 
Причина: каждый элемент требует перемещения через почти весь отсортированный блок, что образует арифметическую сумму операций.

# Сортировка слиянием (Merge Sort)

Определение: 
Рекурсивный алгоритм, который делит массив на части и потом сливает их в отсортированном порядке.

Анализ: 
Массив разбивается напополам до единичных элементов, после чего происходит последовательное слияние.

Временная сложность: $$O(n \log n)$$  
Причина: глубина рекурсии составляет $$\log n$$, на каждом уровне обрабатывается весь массив из $$n$$ элементов.

# Сортировка Шелла (Shell Sort)

Определение:  
Улучшенный алгоритм вставок, который сравнивает элементы, находящиеся на определённых промежутках (gap), сокращая количество перестановок.

Анализ:
На каждом этапе элементы упорядочиваются по указанному интервалу gap, который постепенно уменьшается до 1, в результате чего к концу алгоритма происходит обычная сортировка вставками, но уже на почти отсортированном массиве.

Временная сложность: 
Зависит от выбора последовательности gap; обычно оценивается как $$O(n^{3/2})$$
Причина: увеличенный промежуток gap ускоряет перемещение элементов на большие расстояния, уменьшая общее количество сравнений и перестановок.

# Быстрая сортировка (Quick Sort)

Определение:  
Алгоритм, основанный на подходе «разделяй и властвуй»: выбирается опорный элемент, массив делится на части по его значению и рекурсивно сортируется.

Анализ: 
Опорный элемент разделяет массив на подмассивы с меньшими и большими значениями, после чего рекурсивно выполняется сортировка.

Временная сложность:  
- $$O(n \log n)$$  

Причина: при удачном выборе опорного элемента каждый раз массив делится примерно пополам, что даёт глубину рекурсии $$\log n$$, и на каждом уровне происходит обработка всех $$n$$ элементов. В худшем случае (например, когда массив отсортирован или опорный элемент самый маленький/большой) происходит неравномерное разбиение, и вложенность рекурсии достигает $$n$$.


# Пирамидальная сортировка (Heap Sort)

Определение:  
Метод, использующий структуру данных «куча» для эффективного упорядочивания элементов.

Анализ: 
Сначала строится max-heap из массива, затем максимальный элемент последовательно извлекается и замещается последним элементом массива, структура кучи при этом восстанавливается.

Временная сложность: $$O(n \log n)$$  
Причина: построение кучи выполняется за линейное время $$O(n)$$, а затем происходит $$n-1$$ удалений максимума, каждое из которых занимает $$O(\log n)$$ на "просеивание" элемента в куче.


# Последовательный (линейный) поиск (Linear Search)

Определение:  
Поиск, проверяющий элементы массива по одному до нахождения целевого.

Анализ:  
Элементы рассматриваются один за другим до тех пор, пока не встретится искомый элемент или не закончится список.

Временная сложность: 
- $$O(1)$$   
Причина: поиск идёт последовательно



# Бинарный поиск (Binary Search)

Определение: 
Поиск в отсортированном массиве, который на каждом шаге делит текущую область поиска пополам.

Анализ: 
Сравнивает искомое значение с элементом в середине, сокращая область поиска вдвое на каждом шаге.

Временная сложность: $$O(\log n)$$  
Причина: каждый шаг уменьшает площадь рассмотрения в два раза, что быстро сокращает количество необходимых операций.


# Интерполирующий поиск (Interpolation Search)

Определение:  
Модификация бинарного поиска для равномерно распределённых данных, предсказывающая положение искомого элемента с помощью интерполяции.

Анализ: 
Вычисляет предполагаемый индекс позиционирования искомого значения и начиная с него сужает область поиска.

Временная сложность:  
 $$O(\log \log n)$$
Причина: алгоритм работает эффективно, если значения равномерно распределены, иначе может деградировать до линейного поиска.



# Поиск по Фибоначчи (Fibonacci Search)

Определение:  
Поиск в отсортированном массиве, использующий числа Фибоначчи для определения позиций разделения.

Анализ: 
Область поиска уменьшается с помощью чисел Фибоначчи, что похоже на бинарный поиск, но с более гибким делением индексов.

Временная сложность: $$O(\log n)$$  
Причина: сокращение области поиска происходит по числам Фибоначчи, которые растут экспоненциально, обеспечивая логарифмическую сложность.

#куча — это древовидная структура данных, которая поддерживает определённый порядок между родительскими и дочерними узлами. она часто применяется для реализации эффективных приоритетных очередей. основные операции включают добавление элементов, извлечение минимального или максимального значения и обновление приоритета.

#основные типы куч:

бинарная куча — полное бинарное дерево, где все уровни, кроме, возможно, последнего, полностью заполнены, а узлы последнего уровня располагаются слева направо. бывают два варианта: min-куча, в которой значение родителя не больше значений детей, и max-куча, где родитель больше либо равен детям. главное преимущество бинарной кучи — простота реализации, обычно с помощью массива.

биномиальная куча — структура, состоящая из набора биномиальных деревьев разных размеров, что обеспечивает быстрое слияние куч. каждое дерево имеет чёткую структуру, благодаря чему известны его размер и форма.

куча фибоначчи — улучшенный вариант биномиальной кучи с более эффективными амортизированными временами на операции, такие как уменьшение ключа. обладает более сложной внутренней организацией и алгоритмами.

в сравнении типов куч бинарная куча отличается простотой и скоростью базовых операций, но слияние проводится медленно. биномиальная куча позволяет эффективно сливать, но сложнее в реализации. куча фибоначчи показывает лучшую производительность для операций уменьшения ключа и слияния, но её реализация более сложна.

#хеш-таблица — структура данных для хранения пар «ключ-значение», которая обеспечивает быстрый доступ с помощью хеш-функции, вычисляющей индекс массива для каждого ключа. при коллизиях применяются методы цепочек или открытой адресации.

#реализации в популярных языках:

в python бинарная куча реализована в модуле heapq с функциями heappush и heappop. в c++ обычно создают класс на основе вектора с методами вставки и извлечения минимального элемента. в java — класс с массивом и методами add и pop.

для биномиальной кучи в python нужна собственная реализация классов и методов вставки и слияния. в c++ это структуры узлов с операциями вставки, а в java — классы узлов с поддержкой вставки по ключу.

куча фибоначчи в python реализуется вручную, встроенной поддержки нет. в c++ используются объекты с указателями и методами для вставки и уменьшения ключа. в java чаще всего реализуют учебные версии без стандартных библиотек.

хеш-таблицы в python представлены встроенным типом dict с простым синтаксисом для добавления и доступа. в c++ доступен std::unordered_map с оператором [], а в java — классы HashMap и Hashtable с методом put.

#итог: кучи и хеш-таблицы — ключевые структуры данных с разным уровнем поддержки в языках. python предоставляет удобные встроенные средства для базовых задач, тогда как в c++ и java часто требуется подробное описание классов, но доступны мощные стандартные шаблоны. выбор конкретной реализации зависит от требований производительности и сложности задачи. для большинства повседневных задач подходят бинарные кучи и стандартные хеш-таблицы, а для специализированных — биномиальные и фибоначчиевы кучи.
