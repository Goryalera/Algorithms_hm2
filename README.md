# Algorithms_hm2
#Юркова УИБО 14-24

# Анализ алгоритмов сортировки и поиска

## Анализ алгоритма: Сортировка выбором (Selection Sort)

**Определение:**  
Сортировка выбором — алгоритм, который делит массив на отсортированную и неотсортированную части. На каждом шаге выбирается минимальный элемент из неотсортированной части и меняется местами с первым элементом этой части.

**Анализ:**  
Этот алгоритм находит минимальный элемент в неотсортированной части массива и меняет его местами с первым элементом.  
Внешний цикл `for` выполняется \(n-1\) раз.  
Внутренний цикл `for` в худшем случае выполняется последовательно \(n-1, n-2, \ldots\) раз.  
Общее количество сравнений примерно равно \(n \times (n-1)/2\).

**Временная сложность:** \(O(n^2)\)  
**Почему \(O(n^2)\):** Два вложенных цикла, каждый из которых зависит от \(n\). Внутренний цикл может выполняться до \(n\) раз для каждого из \(n\) проходов внешнего цикла.

---

## Анализ алгоритма: Сортировка обменом (пузырьком) (Bubble Sort)

**Определение:**  
Пузырьковая сортировка — простой алгоритм, который многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они расположены в неправильном порядке.

**Анализ:**  
Алгоритм "всплывает" самый большой элемент к концу массива.  
Внешний цикл `for` выполняется \(n-1\) раз.  
Внутренний цикл в худшем случае выполняется последовательно \(n-1, n-2, \ldots\) раз.  
Оптимизация с помощью флага `swapped` позволяет завершить сортировку раньше, если массив уже отсортирован.

**Временная сложность:**  
Временная сложность: O(n²)
Почему O(n²): Два вложенных цикла, где каждый из них в среднем или худшем случае зависит от n. Внутренний цикл может выполняться до n раз для каждого из n итераций внешнего цикла, что приводит к квадратичной зависимости.
**Почему \(O(n^2)\):** Два вложенных цикла, где каждый из них в среднем или худшем случае зависит от n. Внутренний цикл может выполняться до n раз для каждого из n итераций внешнего цикла, что приводит к квадратичной зависимости.

---

## Анализ алгоритма: Сортировка вставками (Insertion Sort)

**Определение:**  
Алгоритм, где каждый элемент вставляется в правильное место среди ранее отсортированных.

**Анализ:**  
Отсортированная часть растет как новый элемент вставляется.  
Внешний цикл по \(n-1\) элементу, внутренний может выполнить до \(i\) итераций.

**Временная сложность:**  
- Худший случай: \(O(n^2)\)  
- Лучший случай: \(O(n)\).  
- Средний случай: \(O(n^2)\)

**Почему \(O(n^2)\):** Количество операций равно сумме \(1 + 2 + \ldots + (n-1) = n \times (n-1)/2\).

---

## Анализ алгоритма: Сортировка слиянием (Merge Sort)

**Определение:**  
Рекурсивное деление массива на части и их слияние для создания отсортированного массива.

**Анализ:**  
Делит массив на подмассивы размером 1, а затем сливает их отсортированными функцией merge.

**Временная сложность:** \(O(n \log n)\)  
**Почему:** Глубина рекурсии \(\log n\), на уровне каждый элемент обрабатывается \(n\) раз.

---

## Анализ алгоритма: Сортировка Шелла (Shell Sort)

**Определение:**  
Усовершенствованный вариант вставок, сравнивающий элементы на расстоянии gap, которое постепенно уменьшается.

**Анализ:**  
Сортирует элементы на расстоянии gap, затем уменьшает gap.

**Временная сложность:**  
Зависит от последовательности gap, обычно \(O(n^{3/2})\) или \(O(n \log^2 n)\). Может ухудшаться до \(O(n^2)\).

**Почему:** Внутренний цикл зависит от gap, итерации растут медленнее, чем в простых сортах.

---

## Анализ алгоритма: Быстрая сортировка (Quick Sort)

**Определение:**  
Использует стратегию "разделяй и властвуй", выбирая опорный элемент, разделяя массив на части и рекурсивно сортируя их.

**Анализ:**  
Опорный элемент делит массив на подмассивы элементов меньше и больше его, затем рекурсия.

**Временная сложность:**  
- Средний случай: \(O(n \log n)\).  
- Худший случай: \(O(n^2)\).  
- Лучший случай: \(O(n \log n)\).

**Почему:**  
Глубина рекурсии и количество сравнений зависят от выбора опорного элемента.

---

## Анализ алгоритма: Пирамидальная сортировка (Heap Sort)

**Определение:**  
Использует структуру данных "двойная куча" для эффективной сортировки.

**Анализ:**  
Строит max-heap, затем извлекает максимальные элементы по одному, поддерживая структуру кучи.

**Временная сложность:** \(O(n \log n)\)  
**Почему:**  
Построение кучи — \(O(n)\), сортировка — \(n-1\) вызовов heapify по \(O(\log n)\).

---

## Анализ алгоритма: Последовательный (линейный) поиск (Linear Search)

**Определение:**  
Ищет элемент перебором всех элементов массива один за другим.

**Анализ:**  
Простой перебор с проверкой каждого элемента.

**Временная сложность:**  
- Худший случай: \(O(n)\).  
- Лучший случай: \(O(1)\).  
- Средний случай: \(O(n)\).

---

## Анализ алгоритма: Бинарный поиск (Binary Search)

**Определение:**  
Эффективный поиск в отсортированном массиве путем деления области поиска пополам.

**Анализ:**  
Сокращает область поиска вдвое на каждом шаге.

**Временная сложность:** \(O(\log n)\).

---

## Анализ алгоритма: Интерполирующий поиск (Interpolation Search)

**Определение:**  
Улучшение бинарного поиска для равномерно распределённых данных, ориентируется на значение элемента.

**Анализ:**  
Рассчитывает позицию элемента, предполагая равномерное распределение.

**Временная сложность:**  
- Средний случай: \(O(\log \log n)\).  
- Худший случай: \(O(n)\).

---

## Анализ алгоритма: Поиск по Фибоначчи (Fibonacci Search)

**Определение:**  
Итеративный поиск с разбиением массива с помощью чисел Фибоначчи.

**Анализ:**  
Использует последовательность Фибоначчи для деления области поиска.

**Временная сложность:** \(O(\log n)\).

---

Вот перефразированный и красиво оформленный текст с определениями и анализом для README в формате TXT с выделенными большими заголовками. Он также включает переформулированные определения и анализы основных структур данных и их реализаций, описанные в вашем запросе.

***

# КУЧА: ОБЩЕЕ ОПРЕДЕЛЕНИЕ  
Куча — это древовидная структура данных, которая поддерживает упорядоченность между родительскими и дочерними узлами. Она широко используется для создания эффективных очередей с приоритетом. Базовые операции включают добавление новых элементов, извлечение максимального или минимального значения, а также обновление приоритета.

# ОСНОВНЫЕ ТИПЫ КУЧ

## Бинарная куча  
Полное бинарное дерево, в котором все уровни, кроме, возможно, последнего, полностью заполнены. Узлы на неполном последнем уровне заполняются слева направо. Бывают двух видов: min-куча — где значение родителя всегда меньше либо равно значению дочерних элементов, и max-куча — где значение родителя больше либо равно своим детям. Преимущество — простота реализации, обычно через массив.

## Биномиальная куча  
Состоит из набора биномиальных деревьев варьирующегося размера, что обеспечивает быстрые операции слияния куч. Каждое такое дерево строго структурировано, что гарантирует предсказуемость его размера и формы.

## Куча Фибоначчи  
Усовершенствованная версия биномиальной кучи с улучшенной эффективностью некоторых операций, таких как уменьшение ключа. Обладает более сложной внутренней структурой и алгоритмами управления, но обеспечивает лучшие амортизированные временные показатели.

# СРАВНЕНИЕ КУЧ  
- **Бинарная куча** — проста и быстра в основных операциях, но слияние выполняется медленно.  
- **Биномиальная куча** — эффективно поддерживает слияние, однако сложнее в реализации.  
- **Куча Фибоначчи** — наиболее эффективна при операциях уменьшения ключа и слияния, но имеет большую алгоритмическую сложность реализации.

# ОПРЕДЕЛЕНИЕ ХЕШ-ТАБЛИЦ

Хеш-таблица — структура данных для хранения пар ключ-значение с быстрым доступом. Использует хеш-функцию для вычисления индекса массива из ключа. При столкновении ключей (коллизии) применяют цепочки (списки в ячейках) или открытую адресацию.

# СРАВНЕНИЕ РЕАЛИЗАЦИИ КУЧ И ХЕШ-ТАБЛИЦ В PYTHON, C++ И JAVA

## Реализация бинарной кучи  
- **Python:** Модуль `heapq` предоставляет функции `heappush` и `heappop`.  
- **C++:** Класс с использованием вектора и методов `insert` и `extractMin`.  
- **Java:** Класс с массивом и методами `add` и `pop`.

## Реализация биномиальной кучи  
- **Python:** Требует собственной реализации с классами и методами для вставки и слияния.  
- **C++:** Используются структуры узлов и методы вставки.  
- **Java:** Классы с узлами, реализующие вставку элемента по ключу.

## Реализация кучи Фибоначчи  
- **Python:** Нет встроенной поддержки, реализуется вручную с помощью классов.  
- **C++:** Объекты с указателями, методы для вставки и уменьшения ключа.  
- **Java:** Обычно учебная рекурсивная реализация, без встроенных структур.

## Реализация хеш-таблиц  
- **Python:** Встроенный тип `dict` с операциями через присваивание.  
- **C++:** `std::unordered_map`, элементы добавляются оператором `[]`.  
- **Java:** `HashMap` или `Hashtable` с методом `put`.

# ВЫВОД  
Кучи и хеш-таблицы — фундаментальные структуры данных с разным уровнем встроенной поддержки в языках. Python предлагает удобные встроенные реализации для базовых нужд, тогда как в C++ и Java часто необходимо подробно описывать классы, но при этом доступны мощные стандартные шаблоны. Выбор конкретной реализации зависит от требований к эффективности и сложности задач. Для большинства случаев подходят бинарные кучи и стандартные хеш-таблицы, а для более специализированных задач используют биномиальные и Фибоначчиевы кучи.

***


