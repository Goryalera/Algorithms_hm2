# Algorithms_hm2
#Юркова УИБО 14-24


## Сортировка выбором (Selection Sort)

**Определение:**  
Алгоритм, который на каждом шаге находит минимальный элемент в неотсортированной части массива и перемещает его в отсортированную часть.

**Анализ:**  
На каждой итерации выбирается минимальный элемент и меняется местами с первым элементом оставшейся части массива.  
Внешний цикл проходит $$n-1$$ раз, внутренний — уменьшается от $$n-1$$ до 1.  
Число сравнений приближенно равно $$ \frac{n(n-1)}{2} $$.

**Временная сложность:** $$O(n^2)$$  
Причина: из-за двойного вложенного цикла, где внешний перебирает элементы, а внутренний — ищет минимум среди оставшихся, количество операций растёт квадратично.


## Сортировка обменом (Bubble Sort)

**Определение:**  
Простой алгоритм, который многократно проходит по массиву, сравнивая соседние элементы и меняя их местами при необходимости.

**Анализ:**  
"Всплывающий" самый большой элемент постепенно перемещается в конец массива.  
Выполняется $$n-1$$ проход, внутренние циклы сокращаются с каждым проходом.  
Оптимизация с флагом `swapped` позволяет остановить сортировку досрочно, если массив уже отсортирован.

**Временная сложность:** $$O(n^2)$$  
Причина: два вложенных цикла, при которых число сравнений приблизительно равно сумме последовательных чисел от 1 до $$n-1$$, давая квадратичную зависимость.


## Сортировка вставками (Insertion Sort)

**Определение:**  
Алгоритм, который поочерёдно вставляет элементы в отсортированную часть массива, поддерживая порядок.

**Анализ:**  
Отсортированная часть массива расширяется с каждой вставкой.  
Внутренний цикл перемещает элемент на правильную позицию, выполняя до $$i$$ операций на $$i$$-й итерации.

**Временная сложность:**  
- Худший случай: $$O(n^2)$$ — при обратном порядке элементов требуется много сдвигов.  
- Лучший случай: $$O(n)$$ — когда массив уже отсортирован и сдвигов не нужно.  
- Средний случай: $$O(n^2)$$.

Причина: в худшем случае каждый элемент требует перемещения через почти весь отсортированный блок, что образует арифметическую сумму операций.

## Сортировка слиянием (Merge Sort)

**Определение:**  
Рекурсивный алгоритм, который делит массив на части и потом сливает их в отсортированном порядке.

**Анализ:**  
Массив разбивается напополам до единичных элементов, после чего происходит последовательное слияние.

**Временная сложность:** $$O(n \log n)$$  
Причина: глубина рекурсии составляет $$\log n$$, на каждом уровне обрабатывается весь массив из $$n$$ элементов.

## Сортировка Шелла (Shell Sort)

**Определение:**  
Улучшенный алгоритм вставок, который сравнивает элементы, находящиеся на определённых промежутках (gap), сокращая количество перестановок.

**Анализ:**  
На каждом этапе элементы упорядочиваются по указанному интервалу gap, который постепенно уменьшается до 1, в результате чего к концу алгоритма происходит обычная сортировка вставками, но уже на почти отсортированном массиве.

**Временная сложность:**  
Зависит от выбора последовательности gap; обычно оценивается как $$O(n^{3/2})$$ или $$O(n \log^2 n)$$, в худшем случае — $$O(n^2)$$.  
Причина: увеличенный промежуток gap ускоряет перемещение элементов на большие расстояния, уменьшая общее количество сравнений и перестановок; точное время зависит от конкретной последовательности сокращения gap.

## Быстрая сортировка (Quick Sort)

**Определение:**  
Алгоритм, основанный на подходе «разделяй и властвуй»: выбирается опорный элемент, массив делится на части по его значению и рекурсивно сортируется.

**Анализ:**  
Опорный элемент разделяет массив на подмассивы с меньшими и большими значениями, после чего рекурсивно выполняется сортировка.

**Временная сложность:**  
- лучший случаи: $$O(n \log n)$$  

Причина: при удачном выборе опорного элемента каждый раз массив делится примерно пополам, что даёт глубину рекурсии $$\log n$$, и на каждом уровне происходит обработка всех $$n$$ элементов. В худшем случае (например, когда массив отсортирован или опорный элемент самый маленький/большой) происходит неравномерное разбиение, и вложенность рекурсии достигает $$n$$.


## Пирамидальная сортировка (Heap Sort)

**Определение:**  
Метод, использующий структуру данных «куча» для эффективного упорядочивания элементов.

**Анализ:**  
Сначала строится max-heap из массива, затем максимальный элемент последовательно извлекается и замещается последним элементом массива, структура кучи при этом восстанавливается.

**Временная сложность:** $$O(n \log n)$$  
Причина: построение кучи выполняется за линейное время $$O(n)$$, а затем происходит $$n-1$$ удалений максимума, каждое из которых занимает $$O(\log n)$$ на "просеивание" элемента в куче.


## Последовательный (линейный) поиск (Linear Search)

**Определение:**  
Поиск, проверяющий элементы массива по одному до нахождения целевого.

**Анализ:**  
Элементы рассматриваются один за другим до тех пор, пока не встретится искомый элемент или не закончится список.

**Временная сложность:**  
- Лучший случай: $$O(1)$$ — элемент находится на первой позиции.  
- Средний и худший случаи: $$O(n)$$ — требуется проверить большую часть или весь массив.  
Причина: поиск идёт последовательно, и в худшем случае приходится пройти весь массив.

***

## Бинарный поиск (Binary Search)

**Определение:**  
Поиск в отсортированном массиве, который на каждом шаге делит текущую область поиска пополам.

**Анализ:**  
Сравнивает искомое значение с элементом в середине, сокращая область поиска вдвое на каждом шаге.

**Временная сложность:** $$O(\log n)$$  
Причина: каждый шаг уменьшает площадь рассмотрения в два раза, что быстро сокращает количество необходимых операций.

***

## Интерполирующий поиск (Interpolation Search)

**Определение:**  
Модификация бинарного поиска для равномерно распределённых данных, предсказывающая положение искомого элемента с помощью интерполяции.

**Анализ:**  
Вычисляет предполагаемый индекс позиционирования искомого значения и начиная с него сужает область поиска.

**Временная сложность:**  
- Средний случай: $$O(\log \log n)$$ — при равномерности распределения прогноз близок к верному.  
- Худший случай: $$O(n)$$ — при плохом распределении данных или при большом разбросе значений.  
Причина: алгоритм работает эффективно, если значения равномерно распределены, иначе может деградировать до линейного поиска.

***

## Поиск по Фибоначчи (Fibonacci Search)

**Определение:**  
Поиск в отсортированном массиве, использующий числа Фибоначчи для определения позиций разделения.

**Анализ:**  
Область поиска уменьшается с помощью чисел Фибоначчи, что похоже на бинарный поиск, но с более гибким делением индексов.

**Временная сложность:** $$O(\log n)$$  
Причина: сокращение области поиска происходит по числам Фибоначчи, которые растут экспоненциально, обеспечивая логарифмическую сложность.

# КУЧА: ОБЩЕЕ ОПРЕДЕЛЕНИЕ  
Куча — это древовидная структура данных, которая поддерживает упорядоченность между родительскими и дочерними узлами. Она широко используется для создания эффективных очередей с приоритетом. Базовые операции включают добавление новых элементов, извлечение максимального или минимального значения, а также обновление приоритета.

# ОСНОВНЫЕ ТИПЫ КУЧ

## Бинарная куча  
Полное бинарное дерево, в котором все уровни, кроме, возможно, последнего, полностью заполнены. Узлы на неполном последнем уровне заполняются слева направо. Бывают двух видов: min-куча — где значение родителя всегда меньше либо равно значению дочерних элементов, и max-куча — где значение родителя больше либо равно своим детям. Преимущество — простота реализации, обычно через массив.

## Биномиальная куча  
Состоит из набора биномиальных деревьев варьирующегося размера, что обеспечивает быстрые операции слияния куч. Каждое такое дерево строго структурировано, что гарантирует предсказуемость его размера и формы.

## Куча Фибоначчи  
Усовершенствованная версия биномиальной кучи с улучшенной эффективностью некоторых операций, таких как уменьшение ключа. Обладает более сложной внутренней структурой и алгоритмами управления, но обеспечивает лучшие амортизированные временные показатели.

# СРАВНЕНИЕ КУЧ  
- **Бинарная куча** — проста и быстра в основных операциях, но слияние выполняется медленно.  
- **Биномиальная куча** — эффективно поддерживает слияние, однако сложнее в реализации.  
- **Куча Фибоначчи** — наиболее эффективна при операциях уменьшения ключа и слияния, но имеет большую алгоритмическую сложность реализации.

# ОПРЕДЕЛЕНИЕ ХЕШ-ТАБЛИЦ

Хеш-таблица — структура данных для хранения пар ключ-значение с быстрым доступом. Использует хеш-функцию для вычисления индекса массива из ключа. При столкновении ключей (коллизии) применяют цепочки (списки в ячейках) или открытую адресацию.

# СРАВНЕНИЕ РЕАЛИЗАЦИИ КУЧ И ХЕШ-ТАБЛИЦ В PYTHON, C++ И JAVA

## Реализация бинарной кучи  
- **Python:** Модуль `heapq` предоставляет функции `heappush` и `heappop`.  
- **C++:** Класс с использованием вектора и методов `insert` и `extractMin`.  
- **Java:** Класс с массивом и методами `add` и `pop`.

## Реализация биномиальной кучи  
- **Python:** Требует собственной реализации с классами и методами для вставки и слияния.  
- **C++:** Используются структуры узлов и методы вставки.  
- **Java:** Классы с узлами, реализующие вставку элемента по ключу.

## Реализация кучи Фибоначчи  
- **Python:** Нет встроенной поддержки, реализуется вручную с помощью классов.  
- **C++:** Объекты с указателями, методы для вставки и уменьшения ключа.  
- **Java:** Обычно учебная рекурсивная реализация, без встроенных структур.

## Реализация хеш-таблиц  
- **Python:** Встроенный тип `dict` с операциями через присваивание.  
- **C++:** `std::unordered_map`, элементы добавляются оператором `[]`.  
- **Java:** `HashMap` или `Hashtable` с методом `put`.

# ВЫВОД  
Кучи и хеш-таблицы — фундаментальные структуры данных с разным уровнем встроенной поддержки в языках. Python предлагает удобные встроенные реализации для базовых нужд, тогда как в C++ и Java часто необходимо подробно описывать классы, но при этом доступны мощные стандартные шаблоны. Выбор конкретной реализации зависит от требований к эффективности и сложности задач. Для большинства случаев подходят бинарные кучи и стандартные хеш-таблицы, а для более специализированных задач используют биномиальные и Фибоначчиевы кучи.
